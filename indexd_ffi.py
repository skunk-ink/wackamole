

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_indexd_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_indexd_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_indexd_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("indexd_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 29
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_indexd_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_indexd_ffi_checksum_func_encoded_size() != 51818:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_func_generate_recovery_phrase() != 35343:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_func_set_logger() != 36651:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_download_cancel() != 11719:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_download_read_chunk() != 5666:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_encryptionkey_export() != 1252:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_logger_info() != 54729:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_logger_warn() != 48239:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_logger_error() != 23088:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_logger_debug() != 42085:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_pinnedobject_created_at() != 22273:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_pinnedobject_id() != 62787:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_pinnedobject_metadata() != 60113:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_pinnedobject_seal() != 13608:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_pinnedobject_size() != 48206:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_pinnedobject_slabs() != 21596:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_pinnedobject_update_metadata() != 65197:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_pinnedobject_updated_at() != 1712:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_account() != 50707:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_connected() != 35905:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_delete_object() != 39351:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_download() != 58228:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_download_shared() != 22963:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_hosts() != 11119:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_object() != 24221:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_objects() != 37732:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_pin_shared() != 28491:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_prune_slabs() != 23027:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_request_app_connection() != 39927:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_save_object() != 3512:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_share_object() != 18462:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_shared_object() != 39630:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_slab() != 48470:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_upload() != 59481:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sdk_wait_for_connect() != 21385:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sharedobject_metadata() != 43501:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_sharedobject_size() != 31454:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_upload_cancel() != 62647:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_upload_finalize() != 17666:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_upload_write() != 44050:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_method_uploadprogresscallback_progress() != 10119:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_constructor_appkey_new() != 22823:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_constructor_encryptionkey_parse() != 42073:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_constructor_pinnedobject_open() != 56501:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_indexd_ffi_checksum_constructor_sdk_new() != 1321:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_UPLOAD_PROGRESS_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,ctypes.c_uint64,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
class _UniffiVTableCallbackInterfaceLogger(ctypes.Structure):
    _fields_ = [
        ("info", _UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD0),
        ("warn", _UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD1),
        ("error", _UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD2),
        ("debug", _UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD3),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceUploadProgressCallback(ctypes.Structure):
    _fields_ = [
        ("progress", _UNIFFI_CALLBACK_INTERFACE_UPLOAD_PROGRESS_CALLBACK_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_indexd_ffi_fn_clone_appkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_clone_appkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_free_appkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_free_appkey.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_constructor_appkey_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_constructor_appkey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_clone_download.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_clone_download.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_free_download.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_free_download.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_download_cancel.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_download_cancel.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_download_read_chunk.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_download_read_chunk.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_clone_encryptionkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_clone_encryptionkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_free_encryptionkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_free_encryptionkey.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_constructor_encryptionkey_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_constructor_encryptionkey_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_method_encryptionkey_export.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_encryptionkey_export.restype = _UniffiRustBuffer
_UniffiLib.uniffi_indexd_ffi_fn_clone_logger.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_clone_logger.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_free_logger.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_free_logger.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_init_callback_vtable_logger.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceLogger),
)
_UniffiLib.uniffi_indexd_ffi_fn_init_callback_vtable_logger.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_logger_info.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_logger_info.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_logger_warn.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_logger_warn.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_logger_error.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_logger_error.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_logger_debug.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_logger_debug.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_clone_pinnedobject.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_clone_pinnedobject.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_free_pinnedobject.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_free_pinnedobject.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_constructor_pinnedobject_open.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_constructor_pinnedobject_open.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_created_at.restype = _UniffiRustBuffer
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_metadata.restype = _UniffiRustBuffer
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_seal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_seal.restype = _UniffiRustBuffer
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_size.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_slabs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_slabs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_update_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_update_metadata.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_updated_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_updated_at.restype = _UniffiRustBuffer
_UniffiLib.uniffi_indexd_ffi_fn_clone_sdk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_clone_sdk.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_free_sdk.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_free_sdk.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_constructor_sdk_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_constructor_sdk_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_account.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_account.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_connected.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_connected.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_delete_object.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_delete_object.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_download.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_download.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_download_shared.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_download_shared.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_hosts.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_hosts.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_object.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_object.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_objects.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_objects.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_pin_shared.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_pin_shared.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_prune_slabs.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_prune_slabs.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_request_app_connection.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_request_app_connection.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_save_object.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_save_object.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_share_object.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_share_object.restype = _UniffiRustBuffer
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_shared_object.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_shared_object.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_slab.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_slab.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_upload.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_upload.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_wait_for_connect.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_wait_for_connect.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_clone_sharedobject.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_clone_sharedobject.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_free_sharedobject.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_free_sharedobject.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_sharedobject_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sharedobject_metadata.restype = _UniffiRustBuffer
_UniffiLib.uniffi_indexd_ffi_fn_method_sharedobject_size.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_sharedobject_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_clone_upload.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_clone_upload.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_free_upload.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_free_upload.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_upload_cancel.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_upload_cancel.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_upload_finalize.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_upload_finalize.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_method_upload_write.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_indexd_ffi_fn_method_upload_write.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_clone_uploadprogresscallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_clone_uploadprogresscallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_indexd_ffi_fn_free_uploadprogresscallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_free_uploadprogresscallback.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_init_callback_vtable_uploadprogresscallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceUploadProgressCallback),
)
_UniffiLib.uniffi_indexd_ffi_fn_init_callback_vtable_uploadprogresscallback.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_method_uploadprogresscallback_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_method_uploadprogresscallback_progress.restype = None
_UniffiLib.uniffi_indexd_ffi_fn_func_encoded_size.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint8,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_func_encoded_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_indexd_ffi_fn_func_generate_recovery_phrase.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_func_generate_recovery_phrase.restype = _UniffiRustBuffer
_UniffiLib.uniffi_indexd_ffi_fn_func_set_logger.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_indexd_ffi_fn_func_set_logger.restype = None
_UniffiLib.ffi_indexd_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_indexd_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_indexd_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_indexd_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_indexd_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_indexd_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_indexd_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_indexd_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_indexd_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_indexd_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_indexd_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_indexd_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_indexd_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_indexd_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_indexd_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_indexd_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_indexd_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_indexd_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_indexd_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_indexd_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_indexd_ffi_checksum_func_encoded_size.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_func_encoded_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_func_generate_recovery_phrase.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_func_generate_recovery_phrase.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_func_set_logger.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_func_set_logger.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_download_cancel.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_download_cancel.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_download_read_chunk.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_download_read_chunk.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_encryptionkey_export.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_encryptionkey_export.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_logger_info.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_logger_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_logger_warn.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_logger_warn.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_logger_error.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_logger_error.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_logger_debug.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_logger_debug.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_created_at.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_id.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_metadata.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_seal.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_seal.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_size.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_slabs.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_slabs.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_update_metadata.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_update_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_updated_at.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_pinnedobject_updated_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_account.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_account.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_connected.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_connected.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_delete_object.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_delete_object.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_download.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_download.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_download_shared.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_download_shared.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_hosts.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_hosts.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_object.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_object.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_objects.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_objects.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_pin_shared.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_pin_shared.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_prune_slabs.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_prune_slabs.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_request_app_connection.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_request_app_connection.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_save_object.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_save_object.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_share_object.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_share_object.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_shared_object.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_shared_object.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_slab.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_slab.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_upload.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_upload.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_wait_for_connect.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sdk_wait_for_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sharedobject_metadata.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sharedobject_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_sharedobject_size.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_sharedobject_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_upload_cancel.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_upload_cancel.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_upload_finalize.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_upload_finalize.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_upload_write.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_upload_write.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_method_uploadprogresscallback_progress.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_method_uploadprogresscallback_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_constructor_appkey_new.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_constructor_appkey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_constructor_encryptionkey_parse.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_constructor_encryptionkey_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_constructor_pinnedobject_open.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_constructor_pinnedobject_open.restype = ctypes.c_uint16
_UniffiLib.uniffi_indexd_ffi_checksum_constructor_sdk_new.argtypes = (
)
_UniffiLib.uniffi_indexd_ffi_checksum_constructor_sdk_new.restype = ctypes.c_uint16
_UniffiLib.ffi_indexd_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_indexd_ffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.
# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterDouble(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)

# The Timestamp type.
Timestamp = datetime.datetime

# There is a loss of precision when converting from Rust timestamps,
# which are accurate to the nanosecond,
# to Python datetimes, which have a variable precision due to the use of float as representation.
class _UniffiConverterTimestamp(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.read_i64()
        microseconds = buf.read_u32() / 1000
        # Use fromtimestamp(0) then add the seconds using a timedelta.  This
        # ensures that we get OverflowError rather than ValueError when
        # seconds is too large.
        if seconds >= 0:
            return datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc) + datetime.timedelta(seconds=seconds, microseconds=microseconds)
        else:
            return datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc) - datetime.timedelta(seconds=-seconds, microseconds=microseconds)

    @staticmethod
    def check_lower(value):
        pass

    @staticmethod
    def write(value, buf):
        if value >= datetime.datetime.fromtimestamp(0, datetime.timezone.utc):
            sign = 1
            delta = value - datetime.datetime.fromtimestamp(0, datetime.timezone.utc)
        else:
            sign = -1
            delta = datetime.datetime.fromtimestamp(0, datetime.timezone.utc) - value

        seconds = delta.seconds + delta.days * 24 * 3600
        nanoseconds = delta.microseconds * 1000
        buf.write_i64(sign * seconds)
        buf.write_u32(nanoseconds)




















class Account:
    """
    An account registered on the indexer.
    """

    account_key: "str"
    service_account: "bool"
    max_pinned_data: "int"
    pinned_data: "int"
    description: "str"
    logo_url: "typing.Optional[str]"
    service_url: "typing.Optional[str]"
    def __init__(self, *, account_key: "str", service_account: "bool", max_pinned_data: "int", pinned_data: "int", description: "str", logo_url: "typing.Optional[str]", service_url: "typing.Optional[str]"):
        self.account_key = account_key
        self.service_account = service_account
        self.max_pinned_data = max_pinned_data
        self.pinned_data = pinned_data
        self.description = description
        self.logo_url = logo_url
        self.service_url = service_url

    def __str__(self):
        return "Account(account_key={}, service_account={}, max_pinned_data={}, pinned_data={}, description={}, logo_url={}, service_url={})".format(self.account_key, self.service_account, self.max_pinned_data, self.pinned_data, self.description, self.logo_url, self.service_url)

    def __eq__(self, other):
        if self.account_key != other.account_key:
            return False
        if self.service_account != other.service_account:
            return False
        if self.max_pinned_data != other.max_pinned_data:
            return False
        if self.pinned_data != other.pinned_data:
            return False
        if self.description != other.description:
            return False
        if self.logo_url != other.logo_url:
            return False
        if self.service_url != other.service_url:
            return False
        return True

class _UniffiConverterTypeAccount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Account(
            account_key=_UniffiConverterString.read(buf),
            service_account=_UniffiConverterBool.read(buf),
            max_pinned_data=_UniffiConverterUInt64.read(buf),
            pinned_data=_UniffiConverterUInt64.read(buf),
            description=_UniffiConverterString.read(buf),
            logo_url=_UniffiConverterOptionalString.read(buf),
            service_url=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.account_key)
        _UniffiConverterBool.check_lower(value.service_account)
        _UniffiConverterUInt64.check_lower(value.max_pinned_data)
        _UniffiConverterUInt64.check_lower(value.pinned_data)
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.logo_url)
        _UniffiConverterOptionalString.check_lower(value.service_url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.account_key, buf)
        _UniffiConverterBool.write(value.service_account, buf)
        _UniffiConverterUInt64.write(value.max_pinned_data, buf)
        _UniffiConverterUInt64.write(value.pinned_data, buf)
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.logo_url, buf)
        _UniffiConverterOptionalString.write(value.service_url, buf)


class AppMeta:
    """
    Metadata about an application connecting to the indexer.
    """

    name: "str"
    description: "str"
    service_url: "str"
    logo_url: "typing.Optional[str]"
    callback_url: "typing.Optional[str]"
    def __init__(self, *, name: "str", description: "str", service_url: "str", logo_url: "typing.Optional[str]", callback_url: "typing.Optional[str]"):
        self.name = name
        self.description = description
        self.service_url = service_url
        self.logo_url = logo_url
        self.callback_url = callback_url

    def __str__(self):
        return "AppMeta(name={}, description={}, service_url={}, logo_url={}, callback_url={})".format(self.name, self.description, self.service_url, self.logo_url, self.callback_url)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.service_url != other.service_url:
            return False
        if self.logo_url != other.logo_url:
            return False
        if self.callback_url != other.callback_url:
            return False
        return True

class _UniffiConverterTypeAppMeta(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppMeta(
            name=_UniffiConverterString.read(buf),
            description=_UniffiConverterString.read(buf),
            service_url=_UniffiConverterString.read(buf),
            logo_url=_UniffiConverterOptionalString.read(buf),
            callback_url=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.service_url)
        _UniffiConverterOptionalString.check_lower(value.logo_url)
        _UniffiConverterOptionalString.check_lower(value.callback_url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterString.write(value.service_url, buf)
        _UniffiConverterOptionalString.write(value.logo_url, buf)
        _UniffiConverterOptionalString.write(value.callback_url, buf)


class DownloadOptions:
    """
    Provides options for a download operation.
    """

    max_inflight: "int"
    offset: "int"
    length: "typing.Optional[int]"
    def __init__(self, *, max_inflight: "int" = _DEFAULT, offset: "int" = _DEFAULT, length: "typing.Optional[int]" = _DEFAULT):
        if max_inflight is _DEFAULT:
            self.max_inflight = 10
        else:
            self.max_inflight = max_inflight
        if offset is _DEFAULT:
            self.offset = 0
        else:
            self.offset = offset
        if length is _DEFAULT:
            self.length = None
        else:
            self.length = length

    def __str__(self):
        return "DownloadOptions(max_inflight={}, offset={}, length={})".format(self.max_inflight, self.offset, self.length)

    def __eq__(self, other):
        if self.max_inflight != other.max_inflight:
            return False
        if self.offset != other.offset:
            return False
        if self.length != other.length:
            return False
        return True

class _UniffiConverterTypeDownloadOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadOptions(
            max_inflight=_UniffiConverterUInt8.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
            length=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt8.check_lower(value.max_inflight)
        _UniffiConverterUInt64.check_lower(value.offset)
        _UniffiConverterOptionalUInt64.check_lower(value.length)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt8.write(value.max_inflight, buf)
        _UniffiConverterUInt64.write(value.offset, buf)
        _UniffiConverterOptionalUInt64.write(value.length, buf)


class Host:
    """
    Information about a storage provider on the
    Sia network.
    """

    public_key: "str"
    addresses: "typing.List[NetAddress]"
    country_code: "str"
    latitude: "float"
    longitude: "float"
    def __init__(self, *, public_key: "str", addresses: "typing.List[NetAddress]", country_code: "str", latitude: "float", longitude: "float"):
        self.public_key = public_key
        self.addresses = addresses
        self.country_code = country_code
        self.latitude = latitude
        self.longitude = longitude

    def __str__(self):
        return "Host(public_key={}, addresses={}, country_code={}, latitude={}, longitude={})".format(self.public_key, self.addresses, self.country_code, self.latitude, self.longitude)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.addresses != other.addresses:
            return False
        if self.country_code != other.country_code:
            return False
        if self.latitude != other.latitude:
            return False
        if self.longitude != other.longitude:
            return False
        return True

class _UniffiConverterTypeHost(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Host(
            public_key=_UniffiConverterString.read(buf),
            addresses=_UniffiConverterSequenceTypeNetAddress.read(buf),
            country_code=_UniffiConverterString.read(buf),
            latitude=_UniffiConverterDouble.read(buf),
            longitude=_UniffiConverterDouble.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.public_key)
        _UniffiConverterSequenceTypeNetAddress.check_lower(value.addresses)
        _UniffiConverterString.check_lower(value.country_code)
        _UniffiConverterDouble.check_lower(value.latitude)
        _UniffiConverterDouble.check_lower(value.longitude)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.public_key, buf)
        _UniffiConverterSequenceTypeNetAddress.write(value.addresses, buf)
        _UniffiConverterString.write(value.country_code, buf)
        _UniffiConverterDouble.write(value.latitude, buf)
        _UniffiConverterDouble.write(value.longitude, buf)


class NetAddress:
    """
    A network address of a storage provider on the Sia network.
    """

    protocol: "AddressProtocol"
    address: "str"
    def __init__(self, *, protocol: "AddressProtocol", address: "str"):
        self.protocol = protocol
        self.address = address

    def __str__(self):
        return "NetAddress(protocol={}, address={})".format(self.protocol, self.address)

    def __eq__(self, other):
        if self.protocol != other.protocol:
            return False
        if self.address != other.address:
            return False
        return True

class _UniffiConverterTypeNetAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NetAddress(
            protocol=_UniffiConverterTypeAddressProtocol.read(buf),
            address=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAddressProtocol.check_lower(value.protocol)
        _UniffiConverterString.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddressProtocol.write(value.protocol, buf)
        _UniffiConverterString.write(value.address, buf)


class ObjectEvent:
    """
    An ObjectEvent represents an object and whether it was deleted or not.
    """

    key: "str"
    deleted: "bool"
    updated_at: "Timestamp"
    object: "typing.Optional[PinnedObject]"
    def __init__(self, *, key: "str", deleted: "bool", updated_at: "Timestamp", object: "typing.Optional[PinnedObject]"):
        self.key = key
        self.deleted = deleted
        self.updated_at = updated_at
        self.object = object

    def __str__(self):
        return "ObjectEvent(key={}, deleted={}, updated_at={}, object={})".format(self.key, self.deleted, self.updated_at, self.object)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.deleted != other.deleted:
            return False
        if self.updated_at != other.updated_at:
            return False
        if self.object != other.object:
            return False
        return True

class _UniffiConverterTypeObjectEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ObjectEvent(
            key=_UniffiConverterString.read(buf),
            deleted=_UniffiConverterBool.read(buf),
            updated_at=_UniffiConverterTimestamp.read(buf),
            object=_UniffiConverterOptionalTypePinnedObject.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.key)
        _UniffiConverterBool.check_lower(value.deleted)
        _UniffiConverterTimestamp.check_lower(value.updated_at)
        _UniffiConverterOptionalTypePinnedObject.check_lower(value.object)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)
        _UniffiConverterBool.write(value.deleted, buf)
        _UniffiConverterTimestamp.write(value.updated_at, buf)
        _UniffiConverterOptionalTypePinnedObject.write(value.object, buf)


class ObjectsCursor:
    """
    Used to paginate through objects stored in the indexer.

    When syncing changes from an indexer, `after` should be set to the
    last `updated_at` timestamp seen, and `key` should be set to the
    last object's key seen.
    """

    after: "Timestamp"
    key: "str"
    def __init__(self, *, after: "Timestamp", key: "str"):
        self.after = after
        self.key = key

    def __str__(self):
        return "ObjectsCursor(after={}, key={})".format(self.after, self.key)

    def __eq__(self, other):
        if self.after != other.after:
            return False
        if self.key != other.key:
            return False
        return True

class _UniffiConverterTypeObjectsCursor(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ObjectsCursor(
            after=_UniffiConverterTimestamp.read(buf),
            key=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTimestamp.check_lower(value.after)
        _UniffiConverterString.check_lower(value.key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTimestamp.write(value.after, buf)
        _UniffiConverterString.write(value.key, buf)


class PinnedSector:
    """
    A sector stored on a specific host.
    """

    root: "str"
    host_key: "str"
    def __init__(self, *, root: "str", host_key: "str"):
        self.root = root
        self.host_key = host_key

    def __str__(self):
        return "PinnedSector(root={}, host_key={})".format(self.root, self.host_key)

    def __eq__(self, other):
        if self.root != other.root:
            return False
        if self.host_key != other.host_key:
            return False
        return True

class _UniffiConverterTypePinnedSector(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PinnedSector(
            root=_UniffiConverterString.read(buf),
            host_key=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.root)
        _UniffiConverterString.check_lower(value.host_key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.root, buf)
        _UniffiConverterString.write(value.host_key, buf)


class PinnedSlab:
    """
    A PinnedSlab represents a slab that has been pinned to the indexer.
    """

    id: "str"
    encryption_key: "bytes"
    min_shards: "int"
    sectors: "typing.List[PinnedSector]"
    def __init__(self, *, id: "str", encryption_key: "bytes", min_shards: "int", sectors: "typing.List[PinnedSector]"):
        self.id = id
        self.encryption_key = encryption_key
        self.min_shards = min_shards
        self.sectors = sectors

    def __str__(self):
        return "PinnedSlab(id={}, encryption_key={}, min_shards={}, sectors={})".format(self.id, self.encryption_key, self.min_shards, self.sectors)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.encryption_key != other.encryption_key:
            return False
        if self.min_shards != other.min_shards:
            return False
        if self.sectors != other.sectors:
            return False
        return True

class _UniffiConverterTypePinnedSlab(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PinnedSlab(
            id=_UniffiConverterString.read(buf),
            encryption_key=_UniffiConverterBytes.read(buf),
            min_shards=_UniffiConverterUInt8.read(buf),
            sectors=_UniffiConverterSequenceTypePinnedSector.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterBytes.check_lower(value.encryption_key)
        _UniffiConverterUInt8.check_lower(value.min_shards)
        _UniffiConverterSequenceTypePinnedSector.check_lower(value.sectors)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterBytes.write(value.encryption_key, buf)
        _UniffiConverterUInt8.write(value.min_shards, buf)
        _UniffiConverterSequenceTypePinnedSector.write(value.sectors, buf)


class RequestAuthResponse:
    """
    The response from requesting app authorization.

    The `response_url` is the URL the user should visit to authorize the app.
    The `status_url` is the URL the app should poll to check if the user has
    authorized the app.
    """

    response_url: "str"
    status_url: "str"
    def __init__(self, *, response_url: "str", status_url: "str"):
        self.response_url = response_url
        self.status_url = status_url

    def __str__(self):
        return "RequestAuthResponse(response_url={}, status_url={})".format(self.response_url, self.status_url)

    def __eq__(self, other):
        if self.response_url != other.response_url:
            return False
        if self.status_url != other.status_url:
            return False
        return True

class _UniffiConverterTypeRequestAuthResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RequestAuthResponse(
            response_url=_UniffiConverterString.read(buf),
            status_url=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.response_url)
        _UniffiConverterString.check_lower(value.status_url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.response_url, buf)
        _UniffiConverterString.write(value.status_url, buf)


class SealedObject:
    id: "str"
    encrypted_master_key: "bytes"
    slabs: "typing.List[Slab]"
    encrypted_metadata: "bytes"
    signature: "bytes"
    created_at: "Timestamp"
    updated_at: "Timestamp"
    def __init__(self, *, id: "str", encrypted_master_key: "bytes", slabs: "typing.List[Slab]", encrypted_metadata: "bytes", signature: "bytes", created_at: "Timestamp", updated_at: "Timestamp"):
        self.id = id
        self.encrypted_master_key = encrypted_master_key
        self.slabs = slabs
        self.encrypted_metadata = encrypted_metadata
        self.signature = signature
        self.created_at = created_at
        self.updated_at = updated_at

    def __str__(self):
        return "SealedObject(id={}, encrypted_master_key={}, slabs={}, encrypted_metadata={}, signature={}, created_at={}, updated_at={})".format(self.id, self.encrypted_master_key, self.slabs, self.encrypted_metadata, self.signature, self.created_at, self.updated_at)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.encrypted_master_key != other.encrypted_master_key:
            return False
        if self.slabs != other.slabs:
            return False
        if self.encrypted_metadata != other.encrypted_metadata:
            return False
        if self.signature != other.signature:
            return False
        if self.created_at != other.created_at:
            return False
        if self.updated_at != other.updated_at:
            return False
        return True

class _UniffiConverterTypeSealedObject(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SealedObject(
            id=_UniffiConverterString.read(buf),
            encrypted_master_key=_UniffiConverterBytes.read(buf),
            slabs=_UniffiConverterSequenceTypeSlab.read(buf),
            encrypted_metadata=_UniffiConverterBytes.read(buf),
            signature=_UniffiConverterBytes.read(buf),
            created_at=_UniffiConverterTimestamp.read(buf),
            updated_at=_UniffiConverterTimestamp.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterBytes.check_lower(value.encrypted_master_key)
        _UniffiConverterSequenceTypeSlab.check_lower(value.slabs)
        _UniffiConverterBytes.check_lower(value.encrypted_metadata)
        _UniffiConverterBytes.check_lower(value.signature)
        _UniffiConverterTimestamp.check_lower(value.created_at)
        _UniffiConverterTimestamp.check_lower(value.updated_at)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterBytes.write(value.encrypted_master_key, buf)
        _UniffiConverterSequenceTypeSlab.write(value.slabs, buf)
        _UniffiConverterBytes.write(value.encrypted_metadata, buf)
        _UniffiConverterBytes.write(value.signature, buf)
        _UniffiConverterTimestamp.write(value.created_at, buf)
        _UniffiConverterTimestamp.write(value.updated_at, buf)


class Slab:
    """
    A Slab represents a contiguous erasure-coded segment of a file stored on the Sia network.
    """

    id: "str"
    offset: "int"
    length: "int"
    def __init__(self, *, id: "str", offset: "int", length: "int"):
        self.id = id
        self.offset = offset
        self.length = length

    def __str__(self):
        return "Slab(id={}, offset={}, length={})".format(self.id, self.offset, self.length)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.offset != other.offset:
            return False
        if self.length != other.length:
            return False
        return True

class _UniffiConverterTypeSlab(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Slab(
            id=_UniffiConverterString.read(buf),
            offset=_UniffiConverterUInt32.read(buf),
            length=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterUInt32.check_lower(value.offset)
        _UniffiConverterUInt32.check_lower(value.length)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterUInt32.write(value.offset, buf)
        _UniffiConverterUInt32.write(value.length, buf)


class UploadOptions:
    """
    Provides options for an upload operation.
    """

    max_inflight: "int"
    data_shards: "int"
    parity_shards: "int"
    metadata: "typing.Optional[bytes]"
    """
    Optional metadata to attach to the object.
    This will be encrypted with the object's master key.
    """

    progress_callback: "typing.Optional[UploadProgressCallback]"
    """
    Optional callback to report upload progress.
    The callback will be called with the number of bytes uploaded
    and the total encoded size of the upload.
    """

    def __init__(self, *, max_inflight: "int" = _DEFAULT, data_shards: "int" = _DEFAULT, parity_shards: "int" = _DEFAULT, metadata: "typing.Optional[bytes]" = _DEFAULT, progress_callback: "typing.Optional[UploadProgressCallback]" = _DEFAULT):
        if max_inflight is _DEFAULT:
            self.max_inflight = 10
        else:
            self.max_inflight = max_inflight
        if data_shards is _DEFAULT:
            self.data_shards = 10
        else:
            self.data_shards = data_shards
        if parity_shards is _DEFAULT:
            self.parity_shards = 20
        else:
            self.parity_shards = parity_shards
        if metadata is _DEFAULT:
            self.metadata = None
        else:
            self.metadata = metadata
        if progress_callback is _DEFAULT:
            self.progress_callback = None
        else:
            self.progress_callback = progress_callback

    def __str__(self):
        return "UploadOptions(max_inflight={}, data_shards={}, parity_shards={}, metadata={}, progress_callback={})".format(self.max_inflight, self.data_shards, self.parity_shards, self.metadata, self.progress_callback)

    def __eq__(self, other):
        if self.max_inflight != other.max_inflight:
            return False
        if self.data_shards != other.data_shards:
            return False
        if self.parity_shards != other.parity_shards:
            return False
        if self.metadata != other.metadata:
            return False
        if self.progress_callback != other.progress_callback:
            return False
        return True

class _UniffiConverterTypeUploadOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UploadOptions(
            max_inflight=_UniffiConverterUInt8.read(buf),
            data_shards=_UniffiConverterUInt8.read(buf),
            parity_shards=_UniffiConverterUInt8.read(buf),
            metadata=_UniffiConverterOptionalBytes.read(buf),
            progress_callback=_UniffiConverterOptionalTypeUploadProgressCallback.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt8.check_lower(value.max_inflight)
        _UniffiConverterUInt8.check_lower(value.data_shards)
        _UniffiConverterUInt8.check_lower(value.parity_shards)
        _UniffiConverterOptionalBytes.check_lower(value.metadata)
        _UniffiConverterOptionalTypeUploadProgressCallback.check_lower(value.progress_callback)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt8.write(value.max_inflight, buf)
        _UniffiConverterUInt8.write(value.data_shards, buf)
        _UniffiConverterUInt8.write(value.parity_shards, buf)
        _UniffiConverterOptionalBytes.write(value.metadata, buf)
        _UniffiConverterOptionalTypeUploadProgressCallback.write(value.progress_callback, buf)





class AddressProtocol(enum.Enum):
    """
    The protocol used in a network address.
    """

    SIA_MUX = 0
    
    QUIC = 1
    


class _UniffiConverterTypeAddressProtocol(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AddressProtocol.SIA_MUX
        if variant == 2:
            return AddressProtocol.QUIC
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AddressProtocol.SIA_MUX:
            return
        if value == AddressProtocol.QUIC:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AddressProtocol.SIA_MUX:
            buf.write_i32(1)
        if value == AddressProtocol.QUIC:
            buf.write_i32(2)




# AppKeyError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AppKeyError(Exception):
    pass

_UniffiTempAppKeyError = AppKeyError

class AppKeyError:  # type: ignore
    class RecoveryPhrase(_UniffiTempAppKeyError):

        def __repr__(self):
            return "AppKeyError.RecoveryPhrase({})".format(repr(str(self)))
    _UniffiTempAppKeyError.RecoveryPhrase = RecoveryPhrase # type: ignore
    class AppIdLength(_UniffiTempAppKeyError):

        def __repr__(self):
            return "AppKeyError.AppIdLength({})".format(repr(str(self)))
    _UniffiTempAppKeyError.AppIdLength = AppIdLength # type: ignore

AppKeyError = _UniffiTempAppKeyError # type: ignore
del _UniffiTempAppKeyError


class _UniffiConverterTypeAppKeyError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AppKeyError.RecoveryPhrase(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return AppKeyError.AppIdLength(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AppKeyError.RecoveryPhrase):
            return
        if isinstance(value, AppKeyError.AppIdLength):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AppKeyError.RecoveryPhrase):
            buf.write_i32(1)
        if isinstance(value, AppKeyError.AppIdLength):
            buf.write_i32(2)


# ConnectError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ConnectError(Exception):
    pass

_UniffiTempConnectError = ConnectError

class ConnectError:  # type: ignore
    class NotConnected(_UniffiTempConnectError):

        def __repr__(self):
            return "ConnectError.NotConnected({})".format(repr(str(self)))
    _UniffiTempConnectError.NotConnected = NotConnected # type: ignore
    class AlreadyConnected(_UniffiTempConnectError):

        def __repr__(self):
            return "ConnectError.AlreadyConnected({})".format(repr(str(self)))
    _UniffiTempConnectError.AlreadyConnected = AlreadyConnected # type: ignore
    class AppClient(_UniffiTempConnectError):

        def __repr__(self):
            return "ConnectError.AppClient({})".format(repr(str(self)))
    _UniffiTempConnectError.AppClient = AppClient # type: ignore
    class JoinError(_UniffiTempConnectError):

        def __repr__(self):
            return "ConnectError.JoinError({})".format(repr(str(self)))
    _UniffiTempConnectError.JoinError = JoinError # type: ignore
    class Custom(_UniffiTempConnectError):

        def __repr__(self):
            return "ConnectError.Custom({})".format(repr(str(self)))
    _UniffiTempConnectError.Custom = Custom # type: ignore

ConnectError = _UniffiTempConnectError # type: ignore
del _UniffiTempConnectError


class _UniffiConverterTypeConnectError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ConnectError.NotConnected(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ConnectError.AlreadyConnected(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ConnectError.AppClient(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return ConnectError.JoinError(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ConnectError.Custom(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ConnectError.NotConnected):
            return
        if isinstance(value, ConnectError.AlreadyConnected):
            return
        if isinstance(value, ConnectError.AppClient):
            return
        if isinstance(value, ConnectError.JoinError):
            return
        if isinstance(value, ConnectError.Custom):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ConnectError.NotConnected):
            buf.write_i32(1)
        if isinstance(value, ConnectError.AlreadyConnected):
            buf.write_i32(2)
        if isinstance(value, ConnectError.AppClient):
            buf.write_i32(3)
        if isinstance(value, ConnectError.JoinError):
            buf.write_i32(4)
        if isinstance(value, ConnectError.Custom):
            buf.write_i32(5)


# DownloadError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class DownloadError(Exception):
    pass

_UniffiTempDownloadError = DownloadError

class DownloadError:  # type: ignore
    class Download(_UniffiTempDownloadError):

        def __repr__(self):
            return "DownloadError.Download({})".format(repr(str(self)))
    _UniffiTempDownloadError.Download = Download # type: ignore
    class AppClient(_UniffiTempDownloadError):

        def __repr__(self):
            return "DownloadError.AppClient({})".format(repr(str(self)))
    _UniffiTempDownloadError.AppClient = AppClient # type: ignore
    class HexParseError(_UniffiTempDownloadError):

        def __repr__(self):
            return "DownloadError.HexParseError({})".format(repr(str(self)))
    _UniffiTempDownloadError.HexParseError = HexParseError # type: ignore
    class NotConnected(_UniffiTempDownloadError):

        def __repr__(self):
            return "DownloadError.NotConnected({})".format(repr(str(self)))
    _UniffiTempDownloadError.NotConnected = NotConnected # type: ignore
    class Cancelled(_UniffiTempDownloadError):

        def __repr__(self):
            return "DownloadError.Cancelled({})".format(repr(str(self)))
    _UniffiTempDownloadError.Cancelled = Cancelled # type: ignore
    class JoinError(_UniffiTempDownloadError):

        def __repr__(self):
            return "DownloadError.JoinError({})".format(repr(str(self)))
    _UniffiTempDownloadError.JoinError = JoinError # type: ignore
    class Custom(_UniffiTempDownloadError):

        def __repr__(self):
            return "DownloadError.Custom({})".format(repr(str(self)))
    _UniffiTempDownloadError.Custom = Custom # type: ignore

DownloadError = _UniffiTempDownloadError # type: ignore
del _UniffiTempDownloadError


class _UniffiConverterTypeDownloadError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DownloadError.Download(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return DownloadError.AppClient(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return DownloadError.HexParseError(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return DownloadError.NotConnected(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return DownloadError.Cancelled(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return DownloadError.JoinError(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return DownloadError.Custom(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, DownloadError.Download):
            return
        if isinstance(value, DownloadError.AppClient):
            return
        if isinstance(value, DownloadError.HexParseError):
            return
        if isinstance(value, DownloadError.NotConnected):
            return
        if isinstance(value, DownloadError.Cancelled):
            return
        if isinstance(value, DownloadError.JoinError):
            return
        if isinstance(value, DownloadError.Custom):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, DownloadError.Download):
            buf.write_i32(1)
        if isinstance(value, DownloadError.AppClient):
            buf.write_i32(2)
        if isinstance(value, DownloadError.HexParseError):
            buf.write_i32(3)
        if isinstance(value, DownloadError.NotConnected):
            buf.write_i32(4)
        if isinstance(value, DownloadError.Cancelled):
            buf.write_i32(5)
        if isinstance(value, DownloadError.JoinError):
            buf.write_i32(6)
        if isinstance(value, DownloadError.Custom):
            buf.write_i32(7)


# EncryptionKeyParseError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class EncryptionKeyParseError(Exception):
    pass

_UniffiTempEncryptionKeyParseError = EncryptionKeyParseError

class EncryptionKeyParseError:  # type: ignore
    class Base64(_UniffiTempEncryptionKeyParseError):

        def __repr__(self):
            return "EncryptionKeyParseError.Base64({})".format(repr(str(self)))
    _UniffiTempEncryptionKeyParseError.Base64 = Base64 # type: ignore
    class KeyLength(_UniffiTempEncryptionKeyParseError):

        def __repr__(self):
            return "EncryptionKeyParseError.KeyLength({})".format(repr(str(self)))
    _UniffiTempEncryptionKeyParseError.KeyLength = KeyLength # type: ignore

EncryptionKeyParseError = _UniffiTempEncryptionKeyParseError # type: ignore
del _UniffiTempEncryptionKeyParseError


class _UniffiConverterTypeEncryptionKeyParseError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return EncryptionKeyParseError.Base64(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return EncryptionKeyParseError.KeyLength(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, EncryptionKeyParseError.Base64):
            return
        if isinstance(value, EncryptionKeyParseError.KeyLength):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, EncryptionKeyParseError.Base64):
            buf.write_i32(1)
        if isinstance(value, EncryptionKeyParseError.KeyLength):
            buf.write_i32(2)


# Error
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class Error(Exception):
    pass

_UniffiTempError = Error

class Error:  # type: ignore
    class Crypto(_UniffiTempError):

        def __repr__(self):
            return "Error.Crypto({})".format(repr(str(self)))
    _UniffiTempError.Crypto = Crypto # type: ignore
    class AppClient(_UniffiTempError):

        def __repr__(self):
            return "Error.AppClient({})".format(repr(str(self)))
    _UniffiTempError.AppClient = AppClient # type: ignore
    class Quic(_UniffiTempError):

        def __repr__(self):
            return "Error.Quic({})".format(repr(str(self)))
    _UniffiTempError.Quic = Quic # type: ignore
    class HexParseError(_UniffiTempError):

        def __repr__(self):
            return "Error.HexParseError({})".format(repr(str(self)))
    _UniffiTempError.HexParseError = HexParseError # type: ignore
    class NotConnected(_UniffiTempError):

        def __repr__(self):
            return "Error.NotConnected({})".format(repr(str(self)))
    _UniffiTempError.NotConnected = NotConnected # type: ignore
    class SealedObject(_UniffiTempError):

        def __repr__(self):
            return "Error.SealedObject({})".format(repr(str(self)))
    _UniffiTempError.SealedObject = SealedObject # type: ignore
    class JoinError(_UniffiTempError):

        def __repr__(self):
            return "Error.JoinError({})".format(repr(str(self)))
    _UniffiTempError.JoinError = JoinError # type: ignore
    class Custom(_UniffiTempError):

        def __repr__(self):
            return "Error.Custom({})".format(repr(str(self)))
    _UniffiTempError.Custom = Custom # type: ignore

Error = _UniffiTempError # type: ignore
del _UniffiTempError


class _UniffiConverterTypeError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Error.Crypto(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return Error.AppClient(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return Error.Quic(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return Error.HexParseError(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return Error.NotConnected(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return Error.SealedObject(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return Error.JoinError(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return Error.Custom(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, Error.Crypto):
            return
        if isinstance(value, Error.AppClient):
            return
        if isinstance(value, Error.Quic):
            return
        if isinstance(value, Error.HexParseError):
            return
        if isinstance(value, Error.NotConnected):
            return
        if isinstance(value, Error.SealedObject):
            return
        if isinstance(value, Error.JoinError):
            return
        if isinstance(value, Error.Custom):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, Error.Crypto):
            buf.write_i32(1)
        if isinstance(value, Error.AppClient):
            buf.write_i32(2)
        if isinstance(value, Error.Quic):
            buf.write_i32(3)
        if isinstance(value, Error.HexParseError):
            buf.write_i32(4)
        if isinstance(value, Error.NotConnected):
            buf.write_i32(5)
        if isinstance(value, Error.SealedObject):
            buf.write_i32(6)
        if isinstance(value, Error.JoinError):
            buf.write_i32(7)
        if isinstance(value, Error.Custom):
            buf.write_i32(8)


# ObjectError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ObjectError(Exception):
    pass

_UniffiTempObjectError = ObjectError

class ObjectError:  # type: ignore
    class SealedObject(_UniffiTempObjectError):

        def __repr__(self):
            return "ObjectError.SealedObject({})".format(repr(str(self)))
    _UniffiTempObjectError.SealedObject = SealedObject # type: ignore
    class Encoding(_UniffiTempObjectError):

        def __repr__(self):
            return "ObjectError.Encoding({})".format(repr(str(self)))
    _UniffiTempObjectError.Encoding = Encoding # type: ignore

ObjectError = _UniffiTempObjectError # type: ignore
del _UniffiTempObjectError


class _UniffiConverterTypeObjectError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ObjectError.SealedObject(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ObjectError.Encoding(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ObjectError.SealedObject):
            return
        if isinstance(value, ObjectError.Encoding):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ObjectError.SealedObject):
            buf.write_i32(1)
        if isinstance(value, ObjectError.Encoding):
            buf.write_i32(2)


# UploadError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UploadError(Exception):
    pass

_UniffiTempUploadError = UploadError

class UploadError:  # type: ignore
    class Closed(_UniffiTempUploadError):

        def __repr__(self):
            return "UploadError.Closed({})".format(repr(str(self)))
    _UniffiTempUploadError.Closed = Closed # type: ignore
    class Upload(_UniffiTempUploadError):

        def __repr__(self):
            return "UploadError.Upload({})".format(repr(str(self)))
    _UniffiTempUploadError.Upload = Upload # type: ignore
    class Crypto(_UniffiTempUploadError):

        def __repr__(self):
            return "UploadError.Crypto({})".format(repr(str(self)))
    _UniffiTempUploadError.Crypto = Crypto # type: ignore
    class NotConnected(_UniffiTempUploadError):

        def __repr__(self):
            return "UploadError.NotConnected({})".format(repr(str(self)))
    _UniffiTempUploadError.NotConnected = NotConnected # type: ignore
    class JoinError(_UniffiTempUploadError):

        def __repr__(self):
            return "UploadError.JoinError({})".format(repr(str(self)))
    _UniffiTempUploadError.JoinError = JoinError # type: ignore
    class Custom(_UniffiTempUploadError):

        def __repr__(self):
            return "UploadError.Custom({})".format(repr(str(self)))
    _UniffiTempUploadError.Custom = Custom # type: ignore

UploadError = _UniffiTempUploadError # type: ignore
del _UniffiTempUploadError


class _UniffiConverterTypeUploadError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UploadError.Closed(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return UploadError.Upload(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return UploadError.Crypto(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return UploadError.NotConnected(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return UploadError.JoinError(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return UploadError.Custom(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, UploadError.Closed):
            return
        if isinstance(value, UploadError.Upload):
            return
        if isinstance(value, UploadError.Crypto):
            return
        if isinstance(value, UploadError.NotConnected):
            return
        if isinstance(value, UploadError.JoinError):
            return
        if isinstance(value, UploadError.Custom):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, UploadError.Closed):
            buf.write_i32(1)
        if isinstance(value, UploadError.Upload):
            buf.write_i32(2)
        if isinstance(value, UploadError.Crypto):
            buf.write_i32(3)
        if isinstance(value, UploadError.NotConnected):
            buf.write_i32(4)
        if isinstance(value, UploadError.JoinError):
            buf.write_i32(5)
        if isinstance(value, UploadError.Custom):
            buf.write_i32(6)



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePinnedObject(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePinnedObject.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePinnedObject.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePinnedObject.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeUploadProgressCallback(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeUploadProgressCallback.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeUploadProgressCallback.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeUploadProgressCallback.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeObjectsCursor(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeObjectsCursor.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeObjectsCursor.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeObjectsCursor.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceTypeHost(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeHost.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeHost.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeHost.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNetAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeNetAddress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNetAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNetAddress.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeObjectEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeObjectEvent.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeObjectEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeObjectEvent.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePinnedSector(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePinnedSector.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePinnedSector.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePinnedSector.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSlab(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSlab.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSlab.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSlab.read(buf) for i in range(count)
        ]

# objects.
class LoggerProtocol(typing.Protocol):
    def info(self, msg: "str"):
        raise NotImplementedError
    def warn(self, msg: "str"):
        raise NotImplementedError
    def error(self, msg: "str"):
        raise NotImplementedError
    def debug(self, msg: "str"):
        raise NotImplementedError
# Logger is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class Logger():
    def info(self, msg: "str"):
        raise NotImplementedError
    def warn(self, msg: "str"):
        raise NotImplementedError
    def error(self, msg: "str"):
        raise NotImplementedError
    def debug(self, msg: "str"):
        raise NotImplementedError
# `LoggerImpl` is the implementation for a Rust implemented version.
class LoggerImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_free_logger, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_clone_logger, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def info(self, msg: "str") -> None:
        _UniffiConverterString.check_lower(msg)
        
        _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_logger_info,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(msg))






    def warn(self, msg: "str") -> None:
        _UniffiConverterString.check_lower(msg)
        
        _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_logger_warn,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(msg))






    def error(self, msg: "str") -> None:
        _UniffiConverterString.check_lower(msg)
        
        _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_logger_error,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(msg))






    def debug(self, msg: "str") -> None:
        _UniffiConverterString.check_lower(msg)
        
        _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_logger_debug,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(msg))






# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplLogger:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD0
    def info(
            uniffi_handle,
            msg,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeLogger._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(msg), )
            method = uniffi_obj.info
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD1
    def warn(
            uniffi_handle,
            msg,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeLogger._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(msg), )
            method = uniffi_obj.warn
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD2
    def error(
            uniffi_handle,
            msg,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeLogger._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(msg), )
            method = uniffi_obj.error
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_LOGGER_METHOD3
    def debug(
            uniffi_handle,
            msg,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeLogger._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(msg), )
            method = uniffi_obj.debug
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeLogger._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceLogger(
        info,
        warn,
        error,
        debug,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_indexd_ffi_fn_init_callback_vtable_logger(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeLogger:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return LoggerImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: Logger):
        pass

    @staticmethod
    def lower(value: LoggerProtocol):
        return _UniffiConverterTypeLogger._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: LoggerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class UploadProgressCallbackProtocol(typing.Protocol):
    def progress(self, uploaded: "int",encoded_size: "int"):
        raise NotImplementedError
# UploadProgressCallback is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class UploadProgressCallback():
    def progress(self, uploaded: "int",encoded_size: "int"):
        raise NotImplementedError
# `UploadProgressCallbackImpl` is the implementation for a Rust implemented version.
class UploadProgressCallbackImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_free_uploadprogresscallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_clone_uploadprogresscallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def progress(self, uploaded: "int",encoded_size: "int") -> None:
        _UniffiConverterUInt64.check_lower(uploaded)
        
        _UniffiConverterUInt64.check_lower(encoded_size)
        
        _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_uploadprogresscallback_progress,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(uploaded),
        _UniffiConverterUInt64.lower(encoded_size))






# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplUploadProgressCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_UPLOAD_PROGRESS_CALLBACK_METHOD0
    def progress(
            uniffi_handle,
            uploaded,
            encoded_size,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeUploadProgressCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(uploaded), _UniffiConverterUInt64.lift(encoded_size), )
            method = uniffi_obj.progress
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeUploadProgressCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceUploadProgressCallback(
        progress,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_indexd_ffi_fn_init_callback_vtable_uploadprogresscallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeUploadProgressCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return UploadProgressCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: UploadProgressCallback):
        pass

    @staticmethod
    def lower(value: UploadProgressCallbackProtocol):
        return _UniffiConverterTypeUploadProgressCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UploadProgressCallbackProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class AppKeyProtocol(typing.Protocol):
    """
    An AppKey is used to sign requests to the indexer.
    """

    pass
# AppKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class AppKey():
    """
    An AppKey is used to sign requests to the indexer.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, recovery_phrase: "str",app_id: "bytes"):
        """
        Creates a new AppKey from a recovery phrase and a unique app ID.
        The app ID should be a unique 32-byte value. The value is not secret,
        but it should be random and unique to the app.
        """

        _UniffiConverterString.check_lower(recovery_phrase)
        
        _UniffiConverterBytes.check_lower(app_id)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeAppKeyError,_UniffiLib.uniffi_indexd_ffi_fn_constructor_appkey_new,
        _UniffiConverterString.lower(recovery_phrase),
        _UniffiConverterBytes.lower(app_id))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_free_appkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_clone_appkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeAppKey:

    @staticmethod
    def lift(value: int):
        return AppKey._make_instance_(value)

    @staticmethod
    def check_lower(value: AppKey):
        if not isinstance(value, AppKey):
            raise TypeError("Expected AppKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AppKeyProtocol):
        if not isinstance(value, AppKey):
            raise TypeError("Expected AppKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AppKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class DownloadProtocol(typing.Protocol):
    """
    Downloads data from the Sia network. It does so in chunks to support large files in
    arbitrary languages.

    Language bindings should provide a higher-level implementation that wraps a stream.
    """

    def cancel(self, ):
        raise NotImplementedError
    def read_chunk(self, ):
        """
        Reads a chunk of data from the Sia network.

        # Returns
        A vector containing the chunk of data read. If the vector is empty, the end of the download has been reached.
        """

        raise NotImplementedError
# Download is a Rust-only trait - it's a wrapper around a Rust implementation.
class Download():
    """
    Downloads data from the Sia network. It does so in chunks to support large files in
    arbitrary languages.

    Language bindings should provide a higher-level implementation that wraps a stream.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_free_download, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_clone_download, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def cancel(self, ) -> None:
        _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_download_cancel,self._uniffi_clone_pointer(),)





    async def read_chunk(self, ) -> "bytes":
        """
        Reads a chunk of data from the Sia network.

        # Returns
        A vector containing the chunk of data read. If the vector is empty, the end of the download has been reached.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_download_read_chunk(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeDownloadError,

        )





class _UniffiConverterTypeDownload:

    @staticmethod
    def lift(value: int):
        return Download._make_instance_(value)

    @staticmethod
    def check_lower(value: Download):
        if not isinstance(value, Download):
            raise TypeError("Expected Download instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DownloadProtocol):
        if not isinstance(value, Download):
            raise TypeError("Expected Download instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DownloadProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class EncryptionKeyProtocol(typing.Protocol):
    def export(self, ):
        """
        Exports the key as a base64 encoded string.

        This should be used to store the key securely.
        The key should never be shared or transmitted
        in plaintext.
        """

        raise NotImplementedError
# EncryptionKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class EncryptionKey():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_free_encryptionkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_clone_encryptionkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def parse(cls, str: "str"):
        _UniffiConverterString.check_lower(str)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeEncryptionKeyParseError,_UniffiLib.uniffi_indexd_ffi_fn_constructor_encryptionkey_parse,
        _UniffiConverterString.lower(str))
        return cls._make_instance_(pointer)



    def export(self, ) -> "str":
        """
        Exports the key as a base64 encoded string.

        This should be used to store the key securely.
        The key should never be shared or transmitted
        in plaintext.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_encryptionkey_export,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEncryptionKey:

    @staticmethod
    def lift(value: int):
        return EncryptionKey._make_instance_(value)

    @staticmethod
    def check_lower(value: EncryptionKey):
        if not isinstance(value, EncryptionKey):
            raise TypeError("Expected EncryptionKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EncryptionKeyProtocol):
        if not isinstance(value, EncryptionKey):
            raise TypeError("Expected EncryptionKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EncryptionKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class PinnedObjectProtocol(typing.Protocol):
    """
    An object that has been pinned to an indexer. Objects are immutable
    data stored on the Sia network. The data is erasure-coded and distributed across
    multiple storage providers. The object is encrypted with a unique encryption key,
    which is used to encrypt the metadata.

    Custom user-defined metadata can be associated with the object. It is
    recommended to use a portable format like JSON for metadata.

    It can be sealed for secure offline storage or transmission and
    later opened using the app key.

    It has no public fields to prevent accidental leakage or corruption.
    """

    def created_at(self, ):
        """
        Returns the time the object was created.
        """

        raise NotImplementedError
    def id(self, ):
        """
        Returns the object's ID, which is the Blake2b hash of its slabs.
        """

        raise NotImplementedError
    def metadata(self, ):
        """
        Returns the metadata associated with the object.
        """

        raise NotImplementedError
    def seal(self, app_key: "AppKey"):
        """
        Seal the object for offline storage.
        # Arguments
        * `app_key` - The app key used to derive the master key to encrypt the object's encryption key.

        # Returns
        The sealed object.
        """

        raise NotImplementedError
    def size(self, ):
        """
        Returns the total size of the object by summing the lengths of its slabs.
        """

        raise NotImplementedError
    def slabs(self, ):
        """
        Returns the slabs that make up the object.
        """

        raise NotImplementedError
    def update_metadata(self, metadata: "bytes"):
        """
        Updates the metadata associated with the object.
        """

        raise NotImplementedError
    def updated_at(self, ):
        """
        Returns the time the object was last updated.
        """

        raise NotImplementedError
# PinnedObject is a Rust-only trait - it's a wrapper around a Rust implementation.
class PinnedObject():
    """
    An object that has been pinned to an indexer. Objects are immutable
    data stored on the Sia network. The data is erasure-coded and distributed across
    multiple storage providers. The object is encrypted with a unique encryption key,
    which is used to encrypt the metadata.

    Custom user-defined metadata can be associated with the object. It is
    recommended to use a portable format like JSON for metadata.

    It can be sealed for secure offline storage or transmission and
    later opened using the app key.

    It has no public fields to prevent accidental leakage or corruption.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_free_pinnedobject, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_clone_pinnedobject, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def open(cls, app_key: "AppKey",sealed: "SealedObject"):
        """
        Opens a sealed object using the provided app key.

        # Arguments
        * `app_key` - The app key that was used to seal the object.
        * `sealed` - The sealed object to open.

        # Returns
        The unsealed object or an error if the object could not be opened.
        """

        _UniffiConverterTypeAppKey.check_lower(app_key)
        
        _UniffiConverterTypeSealedObject.check_lower(sealed)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeObjectError,_UniffiLib.uniffi_indexd_ffi_fn_constructor_pinnedobject_open,
        _UniffiConverterTypeAppKey.lower(app_key),
        _UniffiConverterTypeSealedObject.lower(sealed))
        return cls._make_instance_(pointer)



    def created_at(self, ) -> "Timestamp":
        """
        Returns the time the object was created.
        """

        return _UniffiConverterTimestamp.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_created_at,self._uniffi_clone_pointer(),)
        )





    def id(self, ) -> "str":
        """
        Returns the object's ID, which is the Blake2b hash of its slabs.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_id,self._uniffi_clone_pointer(),)
        )





    def metadata(self, ) -> "bytes":
        """
        Returns the metadata associated with the object.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_metadata,self._uniffi_clone_pointer(),)
        )





    def seal(self, app_key: "AppKey") -> "SealedObject":
        """
        Seal the object for offline storage.
        # Arguments
        * `app_key` - The app key used to derive the master key to encrypt the object's encryption key.

        # Returns
        The sealed object.
        """

        _UniffiConverterTypeAppKey.check_lower(app_key)
        
        return _UniffiConverterTypeSealedObject.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_seal,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAppKey.lower(app_key))
        )





    def size(self, ) -> "int":
        """
        Returns the total size of the object by summing the lengths of its slabs.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_size,self._uniffi_clone_pointer(),)
        )





    def slabs(self, ) -> "typing.List[Slab]":
        """
        Returns the slabs that make up the object.
        """

        return _UniffiConverterSequenceTypeSlab.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_slabs,self._uniffi_clone_pointer(),)
        )





    def update_metadata(self, metadata: "bytes") -> None:
        """
        Updates the metadata associated with the object.
        """

        _UniffiConverterBytes.check_lower(metadata)
        
        _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_update_metadata,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(metadata))






    def updated_at(self, ) -> "Timestamp":
        """
        Returns the time the object was last updated.
        """

        return _UniffiConverterTimestamp.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_pinnedobject_updated_at,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypePinnedObject:

    @staticmethod
    def lift(value: int):
        return PinnedObject._make_instance_(value)

    @staticmethod
    def check_lower(value: PinnedObject):
        if not isinstance(value, PinnedObject):
            raise TypeError("Expected PinnedObject instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PinnedObjectProtocol):
        if not isinstance(value, PinnedObject):
            raise TypeError("Expected PinnedObject instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PinnedObjectProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SdkProtocol(typing.Protocol):
    """
    An SDK enables interaction with an indexer and
    storage providers on the Sia network.
    """

    def account(self, ):
        """
        Returns the current account.
        """

        raise NotImplementedError
    def connected(self, ):
        """
        Returns true if the app key is authorized, returns false otherwise
        """

        raise NotImplementedError
    def delete_object(self, key: "str"):
        """
        Deletes an object from the indexer.
        """

        raise NotImplementedError
    def download(self, object: "PinnedObject",options: "DownloadOptions"):
        """
        Initiates a download of the data referenced by the object, starting at `offset` and reading `length` bytes.

        # Returns
        A [Download] object that can be used to read the data in chunks
        """

        raise NotImplementedError
    def download_shared(self, shared_object: "SharedObject",options: "DownloadOptions"):
        """
        Initiates a download of the data referenced by the shared object, starting at `offset` and reading `length` bytes.

        # Returns
        A [`Download`] object that can be used to read the data in chunks
        """

        raise NotImplementedError
    def hosts(self, ):
        """
        Returns a list of all usable hosts.
        """

        raise NotImplementedError
    def object(self, key: "str"):
        """
        Returns metadata about a specific object stored in the indexer.
        """

        raise NotImplementedError
    def objects(self, cursor: "typing.Optional[ObjectsCursor]",limit: "int"):
        """
        Returns objects stored in the indexer. When syncing, the caller should
        provide the last `updated_at` timestamp and `key` seen in the `cursor
        parameter to avoid missing or duplicating objects.

        # Arguments
        * `cursor` can be used to paginate through the results. If `cursor` is `None`, the first page of results will be returned.
        * `limit` specifies the maximum number of objects to return.
        """

        raise NotImplementedError
    def pin_shared(self, shared: "SharedObject"):
        """
        Pins a shared object to the indexer and returns a [PinnedObject].
        """

        raise NotImplementedError
    def prune_slabs(self, ):
        """
        Unpins slabs not used by any object on the account.
        """

        raise NotImplementedError
    def request_app_connection(self, meta: "AppMeta"):
        """
        Requests permission for the app to connect to the indexer.

        # Returns
        A URL the user should visit to authorize the app.
        """

        raise NotImplementedError
    def save_object(self, object: "PinnedObject"):
        """
        Saves an object to the indexer.
        """

        raise NotImplementedError
    def share_object(self, object: "PinnedObject",valid_until: "Timestamp"):
        """
        Creates a signed URL that can be used to share object metadata
        with other people using an indexer.
        """

        raise NotImplementedError
    def shared_object(self, shared_url: "str"):
        """
        Retrieves a shared object from a signed URL.
        """

        raise NotImplementedError
    def slab(self, slab_id: "str"):
        """
        Returns metadata about a slab stored in the indexer.
        """

        raise NotImplementedError
    def upload(self, options: "UploadOptions"):
        """
        Uploads data to the Sia network and pins it to the indexer

        # Warnings
        * The `encryption_key` must be unique for every upload. Reusing an
        encryption key will compromise the security of the data.

        # Returns
        An object representing the uploaded data.
        """

        raise NotImplementedError
    def wait_for_connect(self, resp: "RequestAuthResponse"):
        """
        Waits for the user to authorize or reject the app.

        # Returns
        True if the app was authorized, false if it was rejected.
        """

        raise NotImplementedError
# Sdk is a Rust-only trait - it's a wrapper around a Rust implementation.
class Sdk():
    """
    An SDK enables interaction with an indexer and
    storage providers on the Sia network.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, indexer_url: "str",app_key: "AppKey"):
        """
        Creates a new SDK instance.

        # Arguments
        * `indexer_url` - The URL of the indexer to connect to.
        * `app_seed` - A 32-byte seed used to derive the app's private key.

        # Returns
        A new SDK instance.
        """

        _UniffiConverterString.check_lower(indexer_url)
        
        _UniffiConverterTypeAppKey.check_lower(app_key)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_indexd_ffi_fn_constructor_sdk_new,
        _UniffiConverterString.lower(indexer_url),
        _UniffiConverterTypeAppKey.lower(app_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_free_sdk, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_clone_sdk, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def account(self, ) -> "Account":
        """
        Returns the current account.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_account(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAccount.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def connected(self, ) -> "bool":
        """
        Returns true if the app key is authorized, returns false otherwise
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_connected(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_i8,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_i8,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter

    None,

        )



    async def delete_object(self, key: "str") -> None:

        """
        Deletes an object from the indexer.
        """

        _UniffiConverterString.check_lower(key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_delete_object(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(key)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_void,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_void,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def download(self, object: "PinnedObject",options: "DownloadOptions") -> "Download":
        """
        Initiates a download of the data referenced by the object, starting at `offset` and reading `length` bytes.

        # Returns
        A [Download] object that can be used to read the data in chunks
        """

        _UniffiConverterTypePinnedObject.check_lower(object)
        
        _UniffiConverterTypeDownloadOptions.check_lower(options)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_download(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePinnedObject.lower(object),
        _UniffiConverterTypeDownloadOptions.lower(options)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeDownload.lift,
            
    # Error FFI converter
_UniffiConverterTypeDownloadError,

        )



    async def download_shared(self, shared_object: "SharedObject",options: "DownloadOptions") -> "Download":
        """
        Initiates a download of the data referenced by the shared object, starting at `offset` and reading `length` bytes.

        # Returns
        A [`Download`] object that can be used to read the data in chunks
        """

        _UniffiConverterTypeSharedObject.check_lower(shared_object)
        
        _UniffiConverterTypeDownloadOptions.check_lower(options)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_download_shared(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSharedObject.lower(shared_object),
        _UniffiConverterTypeDownloadOptions.lower(options)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeDownload.lift,
            
    # Error FFI converter
_UniffiConverterTypeDownloadError,

        )



    async def hosts(self, ) -> "typing.List[Host]":
        """
        Returns a list of all usable hosts.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_hosts(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeHost.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def object(self, key: "str") -> "PinnedObject":
        """
        Returns metadata about a specific object stored in the indexer.
        """

        _UniffiConverterString.check_lower(key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_object(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(key)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypePinnedObject.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def objects(self, cursor: "typing.Optional[ObjectsCursor]",limit: "int") -> "typing.List[ObjectEvent]":
        """
        Returns objects stored in the indexer. When syncing, the caller should
        provide the last `updated_at` timestamp and `key` seen in the `cursor
        parameter to avoid missing or duplicating objects.

        # Arguments
        * `cursor` can be used to paginate through the results. If `cursor` is `None`, the first page of results will be returned.
        * `limit` specifies the maximum number of objects to return.
        """

        _UniffiConverterOptionalTypeObjectsCursor.check_lower(cursor)
        
        _UniffiConverterUInt32.check_lower(limit)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_objects(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalTypeObjectsCursor.lower(cursor),
        _UniffiConverterUInt32.lower(limit)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeObjectEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def pin_shared(self, shared: "SharedObject") -> "PinnedObject":
        """
        Pins a shared object to the indexer and returns a [PinnedObject].
        """

        _UniffiConverterTypeSharedObject.check_lower(shared)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_pin_shared(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSharedObject.lower(shared)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypePinnedObject.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def prune_slabs(self, ) -> None:

        """
        Unpins slabs not used by any object on the account.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_prune_slabs(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_void,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_void,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def request_app_connection(self, meta: "AppMeta") -> "RequestAuthResponse":
        """
        Requests permission for the app to connect to the indexer.

        # Returns
        A URL the user should visit to authorize the app.
        """

        _UniffiConverterTypeAppMeta.check_lower(meta)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_request_app_connection(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAppMeta.lower(meta)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRequestAuthResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeConnectError,

        )



    async def save_object(self, object: "PinnedObject") -> None:

        """
        Saves an object to the indexer.
        """

        _UniffiConverterTypePinnedObject.check_lower(object)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_save_object(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePinnedObject.lower(object)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_void,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_void,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )




    def share_object(self, object: "PinnedObject",valid_until: "Timestamp") -> "str":
        """
        Creates a signed URL that can be used to share object metadata
        with other people using an indexer.
        """

        _UniffiConverterTypePinnedObject.check_lower(object)
        
        _UniffiConverterTimestamp.check_lower(valid_until)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_indexd_ffi_fn_method_sdk_share_object,self._uniffi_clone_pointer(),
        _UniffiConverterTypePinnedObject.lower(object),
        _UniffiConverterTimestamp.lower(valid_until))
        )




    async def shared_object(self, shared_url: "str") -> "SharedObject":
        """
        Retrieves a shared object from a signed URL.
        """

        _UniffiConverterString.check_lower(shared_url)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_shared_object(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(shared_url)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeSharedObject.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def slab(self, slab_id: "str") -> "PinnedSlab":
        """
        Returns metadata about a slab stored in the indexer.
        """

        _UniffiConverterString.check_lower(slab_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_slab(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(slab_id)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePinnedSlab.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def upload(self, options: "UploadOptions") -> "Upload":
        """
        Uploads data to the Sia network and pins it to the indexer

        # Warnings
        * The `encryption_key` must be unique for every upload. Reusing an
        encryption key will compromise the security of the data.

        # Returns
        An object representing the uploaded data.
        """

        _UniffiConverterTypeUploadOptions.check_lower(options)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_upload(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeUploadOptions.lower(options)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeUpload.lift,
            
    # Error FFI converter
_UniffiConverterTypeUploadError,

        )



    async def wait_for_connect(self, resp: "RequestAuthResponse") -> "bool":
        """
        Waits for the user to authorize or reject the app.

        # Returns
        True if the app was authorized, false if it was rejected.
        """

        _UniffiConverterTypeRequestAuthResponse.check_lower(resp)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_sdk_wait_for_connect(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeRequestAuthResponse.lower(resp)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_i8,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_i8,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeConnectError,

        )





class _UniffiConverterTypeSdk:

    @staticmethod
    def lift(value: int):
        return Sdk._make_instance_(value)

    @staticmethod
    def check_lower(value: Sdk):
        if not isinstance(value, Sdk):
            raise TypeError("Expected Sdk instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SdkProtocol):
        if not isinstance(value, Sdk):
            raise TypeError("Expected Sdk instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SdkProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SharedObjectProtocol(typing.Protocol):
    """
    An object that has been shared from an indexer. Shared objects
    are read-only and cannot be modified. They can be downloaded
    using [Sdk.download_shared] or pinned using [Sdk.pin_shared].

    It has no public fields to prevent accidental leakage or corruption.
    """

    def metadata(self, ):
        """
        Returns the slabs that make up the object.
        """

        raise NotImplementedError
    def size(self, ):
        """
        Returns the size of the object by summing the lengths of its slabs.
        """

        raise NotImplementedError
# SharedObject is a Rust-only trait - it's a wrapper around a Rust implementation.
class SharedObject():
    """
    An object that has been shared from an indexer. Shared objects
    are read-only and cannot be modified. They can be downloaded
    using [Sdk.download_shared] or pinned using [Sdk.pin_shared].

    It has no public fields to prevent accidental leakage or corruption.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_free_sharedobject, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_clone_sharedobject, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def metadata(self, ) -> "bytes":
        """
        Returns the slabs that make up the object.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_sharedobject_metadata,self._uniffi_clone_pointer(),)
        )





    def size(self, ) -> "int":
        """
        Returns the size of the object by summing the lengths of its slabs.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_sharedobject_size,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSharedObject:

    @staticmethod
    def lift(value: int):
        return SharedObject._make_instance_(value)

    @staticmethod
    def check_lower(value: SharedObject):
        if not isinstance(value, SharedObject):
            raise TypeError("Expected SharedObject instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SharedObjectProtocol):
        if not isinstance(value, SharedObject):
            raise TypeError("Expected SharedObject instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SharedObjectProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class UploadProtocol(typing.Protocol):
    """
    Uploads data to the Sia network. It does so in chunks to support large files in
    arbitrary languages.

    Callers should write data using [`Upload::write`] until EoF, then call
    [`Upload::finalize`] to complete the upload and get the metadata. [`Upload::cancel`]
    can be called to abort an in-progress upload.

    Language bindings should provide a higher-level implementation that wraps a stream.
    """

    def cancel(self, ):
        """
        Cancels an in-progress upload. This will drop any data
        that has already been written.
        """

        raise NotImplementedError
    def finalize(self, ):
        """
        Waits for all chunks of data to be pinned to the indexer and
        returns the metadata. Data can no longer be written after
        calling finalize. This function must only be called once.

        The caller must store the metadata locally in order to download
        it in the future.
        """

        raise NotImplementedError
    def write(self, buf: "bytes"):
        """
        Writes a chunk of data to the Sia network. The data will be
        erasure-coded and encrypted before upload.

        Chunks should be written until EoF, then call [`Upload::finalize`].
        """

        raise NotImplementedError
# Upload is a Rust-only trait - it's a wrapper around a Rust implementation.
class Upload():
    """
    Uploads data to the Sia network. It does so in chunks to support large files in
    arbitrary languages.

    Callers should write data using [`Upload::write`] until EoF, then call
    [`Upload::finalize`] to complete the upload and get the metadata. [`Upload::cancel`]
    can be called to abort an in-progress upload.

    Language bindings should provide a higher-level implementation that wraps a stream.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_free_upload, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_clone_upload, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def cancel(self, ) -> None:
        """
        Cancels an in-progress upload. This will drop any data
        that has already been written.
        """

        _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_method_upload_cancel,self._uniffi_clone_pointer(),)





    async def finalize(self, ) -> "PinnedObject":
        """
        Waits for all chunks of data to be pinned to the indexer and
        returns the metadata. Data can no longer be written after
        calling finalize. This function must only be called once.

        The caller must store the metadata locally in order to download
        it in the future.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_upload_finalize(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypePinnedObject.lift,
            
    # Error FFI converter
_UniffiConverterTypeUploadError,

        )



    async def write(self, buf: "bytes") -> None:

        """
        Writes a chunk of data to the Sia network. The data will be
        erasure-coded and encrypted before upload.

        Chunks should be written until EoF, then call [`Upload::finalize`].
        """

        _UniffiConverterBytes.check_lower(buf)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_indexd_ffi_fn_method_upload_write(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(buf)
            ),
            _UniffiLib.ffi_indexd_ffi_rust_future_poll_void,
            _UniffiLib.ffi_indexd_ffi_rust_future_complete_void,
            _UniffiLib.ffi_indexd_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUploadError,

        )





class _UniffiConverterTypeUpload:

    @staticmethod
    def lift(value: int):
        return Upload._make_instance_(value)

    @staticmethod
    def check_lower(value: Upload):
        if not isinstance(value, Upload):
            raise TypeError("Expected Upload instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UploadProtocol):
        if not isinstance(value, Upload):
            raise TypeError("Expected Upload instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UploadProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)

def encoded_size(size: "int",data_shards: "int",parity_shards: "int") -> "int":
    """
    Calculates the encoded size of data given the original size and erasure coding parameters.
    """

    _UniffiConverterUInt64.check_lower(size)
    
    _UniffiConverterUInt8.check_lower(data_shards)
    
    _UniffiConverterUInt8.check_lower(parity_shards)
    
    return _UniffiConverterUInt64.lift(_uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_func_encoded_size,
        _UniffiConverterUInt64.lower(size),
        _UniffiConverterUInt8.lower(data_shards),
        _UniffiConverterUInt8.lower(parity_shards)))


def generate_recovery_phrase() -> "str":
    """
    Generates a new BIP-32 12-word recovery phrase.
    """

    return _UniffiConverterString.lift(_uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_func_generate_recovery_phrase,))


def set_logger(logger: "Logger",level: "str") -> None:
    """
    Sets a foreign logger to receive log messages from the SDK.
    """

    _UniffiConverterTypeLogger.check_lower(logger)
    
    _UniffiConverterString.check_lower(level)
    
    _uniffi_rust_call(_UniffiLib.uniffi_indexd_ffi_fn_func_set_logger,
        _UniffiConverterTypeLogger.lower(logger),
        _UniffiConverterString.lower(level))


__all__ = [
    "InternalError",
    "AddressProtocol",
    "AppKeyError",
    "ConnectError",
    "DownloadError",
    "EncryptionKeyParseError",
    "Error",
    "ObjectError",
    "UploadError",
    "Account",
    "AppMeta",
    "DownloadOptions",
    "Host",
    "NetAddress",
    "ObjectEvent",
    "ObjectsCursor",
    "PinnedSector",
    "PinnedSlab",
    "RequestAuthResponse",
    "SealedObject",
    "Slab",
    "UploadOptions",
    "encoded_size",
    "generate_recovery_phrase",
    "set_logger",
    "AppKey",
    "Download",
    "EncryptionKey",
    "Logger",
    "PinnedObject",
    "Sdk",
    "SharedObject",
    "Upload",
    "UploadProgressCallback",
]

